# Combat Action Processing Design

## Overview

The Combat Action Processing system integrates the Combat Rules Engine, Action Validation System, and Initiative & Turn Management to execute and validate combat actions during encounters. It provides a unified interface for processing attacks, movement, spell casting, bonus actions, and reactions while enforcing D&D 5e SRD action economy rules. The system is event-sourced and deterministic, generating immutable events for all action outcomes.

**Key Design Principles:**
- Pure Kotlin core logic with no Android dependencies
- Event-sourced action processing (all outcomes generate events)
- Deterministic behavior using seeded random number generation
- Integration layer between rules engine and encounter state
- Exhaustive sealed types for actions and results
- SRD-compatible D&D 5e action economy

## Architecture

### Module Location
`core/rules/src/main/kotlin/dev/questweaver/core/rules/actions/`

### Package Structure
```
core/rules/actions/
├── ActionProcessor.kt         # Main action processing coordinator
├── AttackActionHandler.kt     # Attack action processing
├── MovementActionHandler.kt   # Movement action processing
├── SpellActionHandler.kt      # Spell casting processing
├── SpecialActionHandler.kt    # Dodge, Disengage, Help, Ready
├── ReactionHandler.kt         # Reaction processing
├── models/
│   ├── CombatAction.kt        # Sealed interface for all actions
│   ├── ActionContext.kt       # Context needed for action processing
│   ├── ActionResult.kt        # Sealed interface for results
│   └── ReactionTrigger.kt     # Sealed interface for reaction triggers
└── validation/
    └── ActionValidator.kt     # Pre-execution validation
```

### Dependencies
- `core:domain` - Entity definitions (Creature, GameEvent)
- `04-dice-system` - DiceRoller for seeded randomness
- `05-combat-rules` - Attack resolution, damage calculation
- `06-action-validation` - Action legality validation
- `10-initiative-turns` - Turn phase tracking

## Components and Interfaces

### 1. ActionProcessor

Main coordinator that routes actions to appropriate handlers.

```kotlin
class ActionProcessor(
    private val attackHandler: AttackActionHandler,
    private val movementHandler: MovementActionHandler,
    private val spellHandler: SpellActionHandler,
    private val specialHandler: SpecialActionHandler,
    private val reactionHandler: ReactionHandler,
    private val validator: ActionValidator
) {
    /**
     * Processes a combat action.
     *
     * @param action The action to process
     * @param context Current action context (turn state, creatures, map)
     * @return ActionResult with events or error
     */
    suspend fun processAction(
        action: CombatAction,
        context: ActionContext
    ): ActionResult
}
```

**Algorithm:**
1. Validate action using ActionValidator
2. If validation fails, return ActionResult.Failure
3. If validation requires choice, return ActionResult.RequiresChoice
4. Route to appropriate handler based on action type
5. Handler executes action and generates events
6. Return ActionResult.Success with events

### 2. AttackActionHandler

Processes attack actions using the Combat Rules Engine.

```kotlin
class AttackActionHandler(
    private val attackResolver: AttackResolver,
    private val damageCalculator: DamageCalculator
) {
    /**
     * Processes an attack action.
     *
     * @param action Attack action details
     * @param context Current action context
     * @return List of events generated by the attack
     */
    suspend fun handleAttack(
        action: CombatAction.Attack,
        context: ActionContext
    ): List<GameEvent>
}
```

**Algorithm:**
1. Get attacker and target creatures from context
2. Calculate attack bonus and target AC
3. Determine roll modifiers from conditions
4. Use AttackResolver to resolve attack roll
5. If hit, use DamageCalculator to calculate damage
6. Generate AttackResolved event with outcome
7. If target HP reaches 0, generate CreatureDefeated event
8. Return list of events

**Multi-Attack Support:**
```kotlin
/**
 * Processes multiple attacks (Extra Attack feature).
 *
 * @param attacks List of attack actions
 * @param context Current action context
 * @return List of events from all attacks
 */
suspend fun handleMultiAttack(
    attacks: List<CombatAction.Attack>,
    context: ActionContext
): List<GameEvent>
```

### 3. MovementActionHandler

Processes movement actions with pathfinding and opportunity attack triggers.

```kotlin
class MovementActionHandler(
    private val pathfinder: Pathfinder,
    private val reactionHandler: ReactionHandler
) {
    /**
     * Processes a movement action.
     *
     * @param action Movement action details
     * @param context Current action context
     * @return List of events generated by the movement
     */
    suspend fun handleMovement(
        action: CombatAction.Move,
        context: ActionContext
    ): List<GameEvent>
}
```

**Algorithm:**
1. Validate path using pathfinder
2. Calculate movement cost (difficult terrain, etc.)
3. Check if movement remaining is sufficient
4. Identify threatened squares along path
5. For each threatened square, check for opportunity attacks
6. Trigger opportunity attacks via ReactionHandler
7. Generate MoveCommitted event with path and remaining movement
8. Return list of events (movement + any opportunity attacks)

**Dash Action:**
```kotlin
/**
 * Processes a Dash action (doubles movement).
 *
 * @param context Current action context
 * @return DashAction event
 */
suspend fun handleDash(context: ActionContext): List<GameEvent>
```

### 4. SpellActionHandler

Processes spell casting with spell slot consumption and effect resolution.

```kotlin
class SpellActionHandler(
    private val attackResolver: AttackResolver,
    private val savingThrowResolver: SavingThrowResolver,
    private val damageCalculator: DamageCalculator
) {
    /**
     * Processes a spell casting action.
     *
     * @param action Spell action details
     * @param context Current action context
     * @return List of events generated by the spell
     */
    suspend fun handleSpellCast(
        action: CombatAction.CastSpell,
        context: ActionContext
    ): List<GameEvent>
}
```

**Algorithm:**
1. Validate spell slot availability
2. Check bonus action spell restriction (if applicable)
3. Determine spell effect type (attack, save, utility)
4. For spell attacks:
   - Use AttackResolver for each target
   - Use DamageCalculator for damage
5. For saving throw spells:
   - Use SavingThrowResolver for each target
   - Apply effects based on save result
6. Consume spell slot
7. Generate SpellCast event with outcomes
8. Return list of events

**Spell Types:**
```kotlin
sealed interface SpellEffect {
    data class Attack(val targets: List<Long>) : SpellEffect
    data class Save(val dc: Int, val abilityType: AbilityType, val targets: List<Long>) : SpellEffect
    data class Utility(val effect: String) : SpellEffect
}
```

### 5. SpecialActionHandler

Processes special actions (Dodge, Disengage, Help, Ready).

```kotlin
class SpecialActionHandler {
    /**
     * Processes a Dodge action.
     *
     * @param context Current action context
     * @return DodgeAction event
     */
    suspend fun handleDodge(context: ActionContext): List<GameEvent>
    
    /**
     * Processes a Disengage action.
     *
     * @param context Current action context
     * @return DisengageAction event
     */
    suspend fun handleDisengage(context: ActionContext): List<GameEvent>
    
    /**
     * Processes a Help action.
     *
     * @param action Help action details
     * @param context Current action context
     * @return HelpAction event
     */
    suspend fun handleHelp(
        action: CombatAction.Help,
        context: ActionContext
    ): List<GameEvent>
    
    /**
     * Processes a Ready action.
     *
     * @param action Ready action details
     * @param context Current action context
     * @return ReadyAction event
     */
    suspend fun handleReady(
        action: CombatAction.Ready,
        context: ActionContext
    ): List<GameEvent>
}
```

**Ready Action Mechanics:**
- Store prepared action and trigger condition
- When trigger occurs, execute prepared action using reaction
- If trigger doesn't occur before next turn, action is lost

### 6. ReactionHandler

Processes reactions triggered by events during combat.

```kotlin
class ReactionHandler(
    private val attackHandler: AttackActionHandler
) {
    /**
     * Processes a reaction.
     *
     * @param reaction Reaction details
     * @param trigger What triggered the reaction
     * @param context Current action context
     * @return List of events generated by the reaction
     */
    suspend fun handleReaction(
        reaction: CombatAction.Reaction,
        trigger: ReactionTrigger,
        context: ActionContext
    ): List<GameEvent>
    
    /**
     * Identifies creatures that can react to a trigger.
     *
     * @param trigger The trigger event
     * @param context Current action context
     * @return List of creature IDs that can react
     */
    fun identifyReactors(
        trigger: ReactionTrigger,
        context: ActionContext
    ): List<Long>
}
```

**Opportunity Attack Algorithm:**
1. Check if reacting creature has reaction available
2. Check if reacting creature has melee weapon equipped
3. Check if triggering creature moved out of reach
4. Use AttackActionHandler to process attack
5. Mark reaction as consumed
6. Generate ReactionUsed event
7. Return attack events

### 7. ActionValidator

Pre-execution validation using the Action Validation System.

```kotlin
class ActionValidator(
    private val actionValidationSystem: ActionValidationSystem
) {
    /**
     * Validates an action before execution.
     *
     * @param action The action to validate
     * @param context Current action context
     * @return ValidationResult (Valid, Invalid, RequiresChoice)
     */
    fun validate(
        action: CombatAction,
        context: ActionContext
    ): ValidationResult
}
```

**Validation Checks:**
- Action phase availability (action, bonus action, reaction)
- Resource availability (spell slots, movement)
- Range and line-of-effect
- Target validity
- Condition restrictions (incapacitated, stunned, etc.)

## Data Models

### Sealed Action Types

```kotlin
sealed interface CombatAction {
    val actorId: Long
    
    data class Attack(
        override val actorId: Long,
        val targetId: Long,
        val weaponId: Long?,
        val attackBonus: Int,
        val damageDice: String,
        val damageModifier: Int,
        val damageType: DamageType
    ) : CombatAction
    
    data class Move(
        override val actorId: Long,
        val path: List<GridPos>,
        val isDash: Boolean = false
    ) : CombatAction
    
    data class CastSpell(
        override val actorId: Long,
        val spellId: Long,
        val spellLevel: Int,
        val targets: List<Long>,
        val spellEffect: SpellEffect,
        val isBonus Action: Boolean
    ) : CombatAction
    
    data class Dodge(
        override val actorId: Long
    ) : CombatAction
    
    data class Disengage(
        override val actorId: Long
    ) : CombatAction
    
    data class Help(
        override val actorId: Long,
        val targetId: Long,
        val helpType: HelpType  // Attack or AbilityCheck
    ) : CombatAction
    
    data class Ready(
        override val actorId: Long,
        val preparedAction: CombatAction,
        val trigger: String
    ) : CombatAction
    
    data class Reaction(
        override val actorId: Long,
        val reactionType: ReactionType,
        val targetId: Long?
    ) : CombatAction
}

enum class HelpType {
    Attack,
    AbilityCheck
}

enum class ReactionType {
    OpportunityAttack,
    ReadiedAction,
    Shield,  // Spell
    Counterspell,
    Other
}
```

### Action Context

```kotlin
data class ActionContext(
    val sessionId: Long,
    val roundNumber: Int,
    val turnPhase: TurnPhase,
    val creatures: Map<Long, Creature>,
    val mapGrid: MapGrid,
    val activeConditions: Map<Long, Set<Condition>>,
    val readiedActions: Map<Long, ReadiedAction>
)

data class ReadiedAction(
    val creatureId: Long,
    val action: CombatAction,
    val trigger: String
)
```

### Action Results

```kotlin
sealed interface ActionResult {
    data class Success(val events: List<GameEvent>) : ActionResult
    data class Failure(val reason: String) : ActionResult
    data class RequiresChoice(val options: List<ActionOption>) : ActionResult
}

data class ActionOption(
    val id: String,
    val description: String,
    val action: CombatAction
)
```

### Reaction Triggers

```kotlin
sealed interface ReactionTrigger {
    data class CreatureMoved(
        val creatureId: Long,
        val fromPos: GridPos,
        val toPos: GridPos
    ) : ReactionTrigger
    
    data class SpellCast(
        val casterId: Long,
        val spellId: Long,
        val targets: List<Long>
    ) : ReactionTrigger
    
    data class AttackMade(
        val attackerId: Long,
        val targetId: Long
    ) : ReactionTrigger
    
    data class TriggerConditionMet(
        val condition: String
    ) : ReactionTrigger
}
```

### Event Types

```kotlin
data class AttackResolved(
    override val sessionId: Long,
    override val timestamp: Long,
    val attackerId: Long,
    val targetId: Long,
    val attackRoll: Int,
    val attackBonus: Int,
    val targetAC: Int,
    val hit: Boolean,
    val isCritical: Boolean,
    val damage: Int?,
    val damageType: DamageType
) : GameEvent

data class MoveCommitted(
    override val sessionId: Long,
    override val timestamp: Long,
    val creatureId: Long,
    val path: List<GridPos>,
    val movementUsed: Int,
    val movementRemaining: Int
) : GameEvent

data class SpellCast(
    override val sessionId: Long,
    override val timestamp: Long,
    val casterId: Long,
    val spellId: Long,
    val spellLevel: Int,
    val slotConsumed: Int,
    val targets: List<Long>,
    val outcomes: List<SpellOutcome>
) : GameEvent

data class SpellOutcome(
    val targetId: Long,
    val attackRoll: Int?,
    val saveRoll: Int?,
    val success: Boolean,
    val damage: Int?,
    val damageType: DamageType?
)

data class BonusActionTaken(
    override val sessionId: Long,
    override val timestamp: Long,
    val creatureId: Long,
    val actionType: String
) : GameEvent

data class DodgeAction(
    override val sessionId: Long,
    override val timestamp: Long,
    val creatureId: Long
) : GameEvent

data class DisengageAction(
    override val sessionId: Long,
    override val timestamp: Long,
    val creatureId: Long
) : GameEvent

data class HelpAction(
    override val sessionId: Long,
    override val timestamp: Long,
    val helperId: Long,
    val targetId: Long,
    val helpType: HelpType
) : GameEvent

data class ReadyAction(
    override val sessionId: Long,
    override val timestamp: Long,
    val creatureId: Long,
    val preparedAction: CombatAction,
    val trigger: String
) : GameEvent

data class CreatureDefeated(
    override val sessionId: Long,
    override val timestamp: Long,
    val creatureId: Long,
    val defeatedBy: Long?
) : GameEvent
```

## Error Handling

```kotlin
sealed interface ActionError {
    data class InvalidAction(val reason: String) : ActionError
    data class InsufficientResources(val resource: String) : ActionError
    data class OutOfRange(val distance: Int, val maxRange: Int) : ActionError
    data class NoLineOfEffect(val blockedBy: GridPos) : ActionError
    data class ActionNotAvailable(val actionType: ActionType) : ActionError
}
```

## Testing Strategy

### Unit Tests (kotest)

**Coverage Target:** 85%+

**Test Categories:**

1. **Attack Action Tests**
   - Attack hits and misses based on AC
   - Critical hits double damage dice
   - Damage applied to target HP
   - Multiple attacks processed correctly
   - Conditions affect attack rolls

2. **Movement Action Tests**
   - Movement consumes correct amount
   - Difficult terrain doubles cost
   - Opportunity attacks triggered correctly
   - Dash action doubles movement
   - Disengage prevents opportunity attacks

3. **Spell Casting Tests**
   - Spell slots consumed correctly
   - Spell attacks resolved correctly
   - Saving throws resolved correctly
   - Bonus action spell restriction enforced
   - Area-of-effect targets multiple creatures

4. **Special Action Tests**
   - Dodge applies condition until next turn
   - Disengage prevents opportunity attacks
   - Help grants advantage on next roll
   - Ready action stores and triggers correctly

5. **Reaction Tests**
   - Opportunity attacks trigger on movement
   - Reactions consume reaction resource
   - Multiple reactions resolved in initiative order
   - Readied actions execute on trigger

6. **Action Validation Tests**
   - Invalid actions rejected with reason
   - Resource checks prevent illegal actions
   - Range checks enforce distance limits
   - Turn phase checks enforce action economy

7. **Event Generation Tests**
   - All actions generate appropriate events
   - Events contain complete outcome information
   - Events are immutable and serializable

### Integration Tests

```kotlin
test("complete attack sequence generates correct events") {
    val context = createTestContext()
    val action = CombatAction.Attack(
        actorId = 1L,
        targetId = 2L,
        weaponId = null,
        attackBonus = 5,
        damageDice = "1d8",
        damageModifier = 3,
        damageType = DamageType.Slashing
    )
    
    val result = processor.processAction(action, context)
    
    result shouldBeInstanceOf ActionResult.Success::class
    val events = (result as ActionResult.Success).events
    events.first() shouldBeInstanceOf AttackResolved::class
}
```

### Property-Based Tests

```kotlin
test("attack damage never exceeds maximum possible") {
    checkAll(Arb.string(), Arb.int(0..10), Arb.boolean()) { dice, modifier, isCrit ->
        val maxDamage = calculateMaxDamage(dice, modifier, isCrit)
        val outcome = damageCalculator.calculateDamage(dice, modifier, DamageType.Slashing, isCrit, emptySet())
        outcome.finalDamage shouldBeLessThanOrEqual maxDamage
    }
}
```

## Performance Considerations

**Target:** <5ms per action processing operation

**Optimizations:**
- Action validation cached for repeated checks
- Creature lookup by ID uses Map for O(1) access
- Pathfinding results cached during movement
- Event generation uses object pooling for common types
- No allocations in hot paths

## Integration Points

### With Combat Rules Engine (05-combat-rules)
- Uses AttackResolver for attack rolls
- Uses DamageCalculator for damage calculation
- Uses SavingThrowResolver for spell saves

### With Action Validation System (06-action-validation)
- Validates all actions before execution
- Checks resource availability
- Validates range and line-of-effect

### With Initiative & Turn Management (10-initiative-turns)
- Queries TurnPhaseManager for action availability
- Consumes action phases after execution
- Triggers reactions based on initiative order

### With Domain Entities (02-core-domain)
- Creature entities provide stats and resources
- MapGrid provides spatial information
- GameEvent hierarchy includes action events

### With Encounter State (12-encounter-state)
- EncounterViewModel uses ActionProcessor for all actions
- ActionContext built from EncounterUiState
- Events persisted through EventRepository

## Design Decisions

### Why Separate Handlers for Each Action Type?
Each action type has unique logic and dependencies. Separating them improves testability, maintainability, and allows parallel development.

### Why ActionContext Instead of Passing Individual Parameters?
ActionContext bundles all necessary state in one immutable object, making the API cleaner and easier to extend.

### Why Sealed Interfaces for Actions and Results?
Sealed types enable exhaustive when expressions, catching missing cases at compile time and making the API self-documenting.

### Why Integrate Validation Before Execution?
Pre-execution validation prevents invalid state changes and provides clear error messages to the UI layer.

### Why Support Readied Actions?
Readied actions are a core D&D 5e mechanic that adds tactical depth, allowing creatures to respond to specific triggers.

## Future Enhancements (Out of Scope for v1)

- Grapple and shove actions
- Mounted combat actions
- Two-weapon fighting bonus attack
- Concentration checks for spell casters
- Legendary actions for boss creatures
- Lair actions at initiative count 20
- Complex spell effects (polymorph, summoning)
- Environmental hazards and traps
