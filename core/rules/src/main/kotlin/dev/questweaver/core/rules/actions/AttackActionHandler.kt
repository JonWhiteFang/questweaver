package dev.questweaver.core.rules.actions

import dev.questweaver.core.rules.actions.models.ActionContext
import dev.questweaver.core.rules.actions.models.Attack
import dev.questweaver.domain.entities.Creature
import dev.questweaver.domain.events.AttackResolved
import dev.questweaver.domain.events.CreatureDefeated
import dev.questweaver.domain.events.GameEvent
import dev.questweaver.domain.values.DiceRoll

/**
 * Placeholder interface for attack resolution.
 * TODO: Implement as part of 05-combat-rules spec.
 */
interface AttackResolver {
    fun resolveAttack(
        attackBonus: Int,
        targetAC: Int,
        seed: Long
    ): AttackOutcome
}

/**
 * Represents the outcome of an attack roll.
 */
data class AttackOutcome(
    val roll: DiceRoll,
    val hit: Boolean,
    val critical: Boolean
)

/**
 * Placeholder interface for damage calculation.
 * TODO: Implement as part of 05-combat-rules spec.
 */
interface DamageCalculator {
    fun calculateDamage(
        damageDice: String,
        modifier: Int,
        isCritical: Boolean,
        seed: Long
    ): DamageResult
}

/**
 * Represents the result of damage calculation.
 */
data class DamageResult(
    val roll: DiceRoll,
    val totalDamage: Int
)

/**
 * Processes attack actions using the Combat Rules Engine.
 */
class AttackActionHandler(
    private val attackResolver: AttackResolver,
    private val damageCalculator: DamageCalculator
) {
    /**
     * Processes an attack action.
     *
     * @param action Attack action details
     * @param context Current action context
     * @return List of events generated by the attack
     */
    suspend fun handleAttack(
        action: Attack,
        context: ActionContext
    ): List<GameEvent> {
        val events = mutableListOf<GameEvent>()
        
        // Get target creature from context
        val target = context.creatures[action.targetId]
            ?: throw IllegalArgumentException("Target not found: ${action.targetId}")
        
        // Calculate target AC
        val targetAC = target.armorClass
        
        // Determine roll modifiers from conditions
        // TODO: Apply advantage/disadvantage from conditions
        
        // Use AttackResolver to resolve attack roll
        val attackOutcome = attackResolver.resolveAttack(
            attackBonus = action.attackBonus,
            targetAC = targetAC,
            seed = context.sessionId + context.roundNumber
        )
        
        // Calculate damage if hit
        val damageResult = if (attackOutcome.hit) {
            damageCalculator.calculateDamage(
                damageDice = action.damageDice,
                modifier = action.damageModifier,
                isCritical = attackOutcome.critical,
                seed = context.sessionId + context.roundNumber + 1
            )
        } else {
            null
        }
        
        // Generate AttackResolved event with outcome
        events.add(
            AttackResolved(
                sessionId = context.sessionId,
                timestamp = System.currentTimeMillis(),
                attackerId = action.actorId,
                targetId = action.targetId,
                attackRoll = attackOutcome.roll,
                targetAC = targetAC,
                hit = attackOutcome.hit,
                critical = attackOutcome.critical
            )
        )
        
        // If target HP reaches 0, generate CreatureDefeated event
        if (damageResult != null) {
            val newHP = target.hitPointsCurrent - damageResult.totalDamage
            if (newHP <= 0) {
                events.add(
                    CreatureDefeated(
                        sessionId = context.sessionId,
                        timestamp = System.currentTimeMillis(),
                        creatureId = action.targetId,
                        defeatedBy = action.actorId
                    )
                )
            }
        }
        
        return events
    }
    
    /**
     * Processes multiple attacks (Extra Attack feature).
     *
     * @param attacks List of attack actions
     * @param context Current action context
     * @return List of events from all attacks
     */
    suspend fun handleMultiAttack(
        attacks: List<Attack>,
        context: ActionContext
    ): List<GameEvent> {
        val allEvents = mutableListOf<GameEvent>()
        
        // Process each attack sequentially
        for (attack in attacks) {
            val events = handleAttack(attack, context)
            allEvents.addAll(events)
        }
        
        return allEvents
    }
}
