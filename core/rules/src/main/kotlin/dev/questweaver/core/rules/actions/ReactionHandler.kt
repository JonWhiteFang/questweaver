package dev.questweaver.core.rules.actions

import dev.questweaver.core.rules.actions.models.ActionContext
import dev.questweaver.core.rules.actions.models.Attack
import dev.questweaver.core.rules.actions.models.Reaction
import dev.questweaver.core.rules.actions.models.ReactionTrigger
import dev.questweaver.core.rules.actions.models.ReactionType
import dev.questweaver.domain.events.GameEvent
import dev.questweaver.domain.values.GridPos

/**
 * Processes reactions triggered by events during combat.
 */
class ReactionHandler(
    private val attackHandler: AttackActionHandler
) {
    companion object {
        private const val MELEE_RANGE_FEET = 5
        private const val FEET_PER_SQUARE = 5
        private const val PLACEHOLDER_ENCOUNTER_ID = 0L
    }
    /**
     * Processes a reaction.
     *
     * @param reaction Reaction details
     * @param trigger What triggered the reaction
     * @param context Current action context
     * @return List of events generated by the reaction
     */
    suspend fun handleReaction(
        reaction: Reaction,
        trigger: ReactionTrigger,
        context: ActionContext
    ): List<GameEvent> {
        val events = mutableListOf<GameEvent>()
        
        // Validate reaction is available
        // TODO: Check if creature has reaction available in turn phase manager
        
        // Process reaction based on type
        when (reaction.reactionType) {
            ReactionType.OpportunityAttack -> {
                if (trigger is ReactionTrigger.CreatureMoved && reaction.targetId != null) {
                    val opportunityAttackEvents = handleOpportunityAttack(
                        reactorId = reaction.actorId,
                        targetId = reaction.targetId,
                        trigger = trigger,
                        context = context
                    )
                    events.addAll(opportunityAttackEvents)
                }
            }
            
            ReactionType.ReadiedAction -> {
                // Execute the readied action
                val readiedAction = context.readiedActions[reaction.actorId]
                if (readiedAction != null) {
                    // TODO: Execute the prepared action
                    // This would require recursively calling the action processor
                }
            }
            
            ReactionType.Shield,
            ReactionType.Counterspell,
            ReactionType.Other -> {
                // These reactions have specific spell/ability effects
                // TODO: Implement specific reaction effects
            }
        }
        
        // Mark reaction as consumed
        // TODO: Update turn phase manager
        
        // Generate ReactionUsed event
        // Note: Using EncounterEvents.ReactionUsed which requires encounterId
        // TODO: Add encounterId to ActionContext
        events.add(
            dev.questweaver.domain.events.ReactionUsed(
                sessionId = context.sessionId,
                timestamp = System.currentTimeMillis(),
                encounterId = PLACEHOLDER_ENCOUNTER_ID,
                creatureId = reaction.actorId,
                reactionType = reaction.reactionType.name,
                trigger = trigger.toString()
            )
        )
        
        return events
    }
    
    /**
     * Identifies creatures that can react to a trigger.
     *
     * @param trigger The trigger event
     * @param context Current action context
     * @return List of creature IDs that can react, sorted by initiative order
     */
    fun identifyReactors(
        trigger: ReactionTrigger,
        context: ActionContext
    ): List<Long> {
        return when (trigger) {
            is ReactionTrigger.CreatureMoved -> findOpportunityAttackers(trigger, context)
            is ReactionTrigger.SpellCast -> findCounterspellers(trigger, context)
            is ReactionTrigger.AttackMade -> findDefensiveReactors(trigger, context)
            is ReactionTrigger.TriggerConditionMet -> findReadiedActionReactors(trigger, context)
        }
    }
    
    private fun findOpportunityAttackers(
        trigger: ReactionTrigger.CreatureMoved,
        context: ActionContext
    ): List<Long> {
        if (!context.creatures.containsKey(trigger.creatureId)) {
            return emptyList()
        }
        
        val reactors = mutableListOf<Long>()
        
        for ((creatureId, creature) in context.creatures) {
            if (creatureId == trigger.creatureId) continue
            
            // Check if creature has reaction available
            // TODO: Query turn phase manager for reaction availability
            
            // Check if creature is within melee range of the from position
            val distance = calculateDistance(creature.position, trigger.fromPos)
            if (distance <= MELEE_RANGE_FEET) {
                reactors.add(creatureId)
            }
        }
        
        return reactors
    }
    
    private fun findCounterspellers(
        trigger: ReactionTrigger.SpellCast,
        context: ActionContext
    ): List<Long> {
        val reactors = mutableListOf<Long>()
        
        for ((creatureId, _) in context.creatures) {
            if (creatureId == trigger.casterId) continue
            
            // Check if creature has reaction available
            // TODO: Query turn phase manager for reaction availability
            
            // Check if creature has counterspell prepared
            // TODO: Check creature's spell list
        }
        
        return reactors
    }
    
    private fun findDefensiveReactors(
        trigger: ReactionTrigger.AttackMade,
        context: ActionContext
    ): List<Long> {
        if (!context.creatures.containsKey(trigger.targetId)) {
            return emptyList()
        }
        
        val reactors = mutableListOf<Long>()
        
        // Check if target has reaction available
        // TODO: Query turn phase manager for reaction availability
        
        // Check if target has defensive reactions available
        // TODO: Check creature's spell list and abilities
        
        return reactors
    }
    
    private fun findReadiedActionReactors(
        trigger: ReactionTrigger.TriggerConditionMet,
        context: ActionContext
    ): List<Long> {
        val reactors = mutableListOf<Long>()
        
        for ((creatureId, readiedAction) in context.readiedActions) {
            // Simple string matching for trigger condition
            // TODO: Implement more sophisticated trigger matching
            if (readiedAction.trigger.contains(trigger.condition, ignoreCase = true)) {
                reactors.add(creatureId)
            }
        }
        
        return reactors
    }
    
    /**
     * Handles an opportunity attack.
     *
     * @param reactorId The creature making the opportunity attack
     * @param targetId The creature being attacked
     * @param trigger The movement trigger
     * @param context Current action context
     * @return List of events from the attack
     */
    private suspend fun handleOpportunityAttack(
        reactorId: Long,
        targetId: Long,
        trigger: ReactionTrigger.CreatureMoved,
        context: ActionContext
    ): List<GameEvent> {
        // Check if reacting creature has reaction available
        // TODO: Query turn phase manager
        
        // Check if reacting creature has melee weapon equipped
        val reactor = context.creatures[reactorId] ?: return emptyList()
        
        // TODO: Get weapon from creature's equipment
        // For now, assume a basic melee attack
        
        // Check if triggering creature moved out of reach and process attack
        return if (isOutOfReach(reactor.position, trigger.toPos)) {
            val attack = createOpportunityAttack(reactor, targetId)
            attackHandler.handleAttack(attack, context)
        } else {
            emptyList()
        }
    }
    
    private fun isOutOfReach(reactorPos: GridPos, targetPos: GridPos): Boolean {
        val distance = calculateDistance(reactorPos, targetPos)
        return distance > MELEE_RANGE_FEET
    }
    
    private fun createOpportunityAttack(
        reactor: dev.questweaver.domain.entities.Creature,
        targetId: Long
    ): Attack {
        return Attack(
            actorId = reactor.id,
            targetId = targetId,
            weaponId = null,
            attackBonus = reactor.proficiencyBonus + reactor.abilities.strModifier,
            damageDice = "1d8",
            damageModifier = reactor.abilities.strModifier,
            damageType = dev.questweaver.core.rules.actions.models.DamageType.Slashing
        )
    }
    
    /**
     * Calculates the distance between two grid positions.
     *
     * @param pos1 First position
     * @param pos2 Second position
     * @return Distance in feet (assuming 5 feet per square)
     */
    private fun calculateDistance(pos1: GridPos, pos2: GridPos): Int {
        val dx = kotlin.math.abs(pos1.x - pos2.x)
        val dy = kotlin.math.abs(pos1.y - pos2.y)
        return kotlin.math.max(dx, dy) * FEET_PER_SQUARE
    }
}

// Extension property to get creature position
// TODO: Move this to Creature entity or get from map state
private val dev.questweaver.domain.entities.Creature.position: GridPos
    get() = GridPos(0, 0) // Placeholder
