package dev.questweaver.core.rules.actions

import dev.questweaver.core.rules.actions.models.ActionContext
import dev.questweaver.core.rules.actions.models.Attack
import dev.questweaver.core.rules.actions.models.Reaction
import dev.questweaver.core.rules.actions.models.ReactionTrigger
import dev.questweaver.core.rules.actions.models.ReactionType
import dev.questweaver.domain.events.GameEvent
import dev.questweaver.domain.values.GridPos

/**
 * Processes reactions triggered by events during combat.
 */
class ReactionHandler(
    private val attackHandler: AttackActionHandler
) {
    /**
     * Processes a reaction.
     *
     * @param reaction Reaction details
     * @param trigger What triggered the reaction
     * @param context Current action context
     * @return List of events generated by the reaction
     */
    suspend fun handleReaction(
        reaction: Reaction,
        trigger: ReactionTrigger,
        context: ActionContext
    ): List<GameEvent> {
        val events = mutableListOf<GameEvent>()
        
        // Validate reaction is available
        // TODO: Check if creature has reaction available in turn phase manager
        
        // Process reaction based on type
        when (reaction.reactionType) {
            ReactionType.OpportunityAttack -> {
                if (trigger is ReactionTrigger.CreatureMoved && reaction.targetId != null) {
                    val opportunityAttackEvents = handleOpportunityAttack(
                        reactorId = reaction.actorId,
                        targetId = reaction.targetId,
                        trigger = trigger,
                        context = context
                    )
                    events.addAll(opportunityAttackEvents)
                }
            }
            
            ReactionType.ReadiedAction -> {
                // Execute the readied action
                val readiedAction = context.readiedActions[reaction.actorId]
                if (readiedAction != null) {
                    // TODO: Execute the prepared action
                    // This would require recursively calling the action processor
                }
            }
            
            ReactionType.Shield,
            ReactionType.Counterspell,
            ReactionType.Other -> {
                // These reactions have specific spell/ability effects
                // TODO: Implement specific reaction effects
            }
        }
        
        // Mark reaction as consumed
        // TODO: Update turn phase manager
        
        // Generate ReactionUsed event
        // Note: Using EncounterEvents.ReactionUsed which requires encounterId
        // TODO: Add encounterId to ActionContext
        events.add(
            dev.questweaver.domain.events.ReactionUsed(
                sessionId = context.sessionId,
                timestamp = System.currentTimeMillis(),
                encounterId = 0L, // TODO: Get from context
                creatureId = reaction.actorId,
                reactionType = reaction.reactionType.name,
                trigger = trigger.toString()
            )
        )
        
        return events
    }
    
    /**
     * Identifies creatures that can react to a trigger.
     *
     * @param trigger The trigger event
     * @param context Current action context
     * @return List of creature IDs that can react, sorted by initiative order
     */
    fun identifyReactors(
        trigger: ReactionTrigger,
        context: ActionContext
    ): List<Long> {
        val reactors = mutableListOf<Long>()
        
        when (trigger) {
            is ReactionTrigger.CreatureMoved -> {
                // Find creatures that can make opportunity attacks
                val movingCreature = context.creatures[trigger.creatureId]
                if (movingCreature != null) {
                    // Check each creature to see if they can react
                    for ((creatureId, creature) in context.creatures) {
                        if (creatureId == trigger.creatureId) continue
                        
                        // Check if creature has reaction available
                        // TODO: Query turn phase manager for reaction availability
                        
                        // Check if creature is within melee range of the from position
                        val distance = calculateDistance(creature.position, trigger.fromPos)
                        if (distance <= 5) { // 5 feet = 1 square for melee
                            reactors.add(creatureId)
                        }
                    }
                }
            }
            
            is ReactionTrigger.SpellCast -> {
                // Find creatures that can counterspell
                for ((creatureId, creature) in context.creatures) {
                    if (creatureId == trigger.casterId) continue
                    
                    // Check if creature has reaction available
                    // TODO: Query turn phase manager for reaction availability
                    
                    // Check if creature has counterspell prepared
                    // TODO: Check creature's spell list
                }
            }
            
            is ReactionTrigger.AttackMade -> {
                // Find creatures that can use Shield or other defensive reactions
                val target = context.creatures[trigger.targetId]
                if (target != null) {
                    // Check if target has reaction available
                    // TODO: Query turn phase manager for reaction availability
                    
                    // Check if target has defensive reactions available
                    // TODO: Check creature's spell list and abilities
                }
            }
            
            is ReactionTrigger.TriggerConditionMet -> {
                // Find creatures with readied actions matching this trigger
                for ((creatureId, readiedAction) in context.readiedActions) {
                    // Simple string matching for trigger condition
                    // TODO: Implement more sophisticated trigger matching
                    if (readiedAction.trigger.contains(trigger.condition, ignoreCase = true)) {
                        reactors.add(creatureId)
                    }
                }
            }
        }
        
        // Sort by initiative order (highest first)
        // TODO: Get initiative order from turn phase manager
        // For now, just return the list as-is
        
        return reactors
    }
    
    /**
     * Handles an opportunity attack.
     *
     * @param reactorId The creature making the opportunity attack
     * @param targetId The creature being attacked
     * @param trigger The movement trigger
     * @param context Current action context
     * @return List of events from the attack
     */
    private suspend fun handleOpportunityAttack(
        reactorId: Long,
        targetId: Long,
        trigger: ReactionTrigger.CreatureMoved,
        context: ActionContext
    ): List<GameEvent> {
        // Check if reacting creature has reaction available
        // TODO: Query turn phase manager
        
        // Check if reacting creature has melee weapon equipped
        val reactor = context.creatures[reactorId]
            ?: return emptyList()
        
        // TODO: Get weapon from creature's equipment
        // For now, assume a basic melee attack
        
        // Check if triggering creature moved out of reach
        val distance = calculateDistance(reactor.position, trigger.toPos)
        if (distance > 5) { // Moved out of 5-foot reach
            // Create attack action
            val attack = Attack(
                actorId = reactorId,
                targetId = targetId,
                weaponId = null,
                attackBonus = reactor.proficiencyBonus + reactor.abilities.strModifier,
                damageDice = "1d8",
                damageModifier = reactor.abilities.strModifier,
                damageType = dev.questweaver.core.rules.actions.models.DamageType.Slashing
            )
            
            // Use AttackActionHandler to process attack
            return attackHandler.handleAttack(attack, context)
        }
        
        return emptyList()
    }
    
    /**
     * Calculates the distance between two grid positions.
     *
     * @param pos1 First position
     * @param pos2 Second position
     * @return Distance in feet (assuming 5 feet per square)
     */
    private fun calculateDistance(pos1: GridPos, pos2: GridPos): Int {
        val dx = kotlin.math.abs(pos1.x - pos2.x)
        val dy = kotlin.math.abs(pos1.y - pos2.y)
        return kotlin.math.max(dx, dy) * 5 // 5 feet per square
    }
}

// Extension property to get creature position
// TODO: Move this to Creature entity or get from map state
private val dev.questweaver.domain.entities.Creature.position: GridPos
    get() = GridPos(0, 0) // Placeholder
