package dev.questweaver.core.rules.actions

import dev.questweaver.core.rules.actions.models.ActionContext
import dev.questweaver.core.rules.actions.models.CastSpell
import dev.questweaver.core.rules.actions.models.SpellEffect
import dev.questweaver.domain.entities.Creature
import dev.questweaver.domain.events.GameEvent
import dev.questweaver.domain.events.SpellCast
import dev.questweaver.domain.events.SpellOutcome
import dev.questweaver.domain.values.AbilityType
import dev.questweaver.domain.values.DiceRoll

/**
 * Placeholder interface for saving throw resolution.
 * TODO: Implement as part of 05-combat-rules spec.
 */
interface SavingThrowResolver {
    fun resolveSave(
        dc: Int,
        abilityType: AbilityType,
        creatureModifier: Int,
        seed: Long
    ): SaveOutcome
}

/**
 * Represents the outcome of a saving throw.
 */
data class SaveOutcome(
    val roll: Int,
    val success: Boolean
)

/**
 * Processes spell casting actions with spell slot consumption and effect resolution.
 */
class SpellActionHandler(
    private val attackResolver: AttackResolver,
    private val savingThrowResolver: SavingThrowResolver,
    private val damageCalculator: DamageCalculator
) {
    /**
     * Processes a spell casting action.
     *
     * @param action Spell action details
     * @param context Current action context
     * @return List of events generated by the spell
     */
    suspend fun handleSpellCast(
        action: CastSpell,
        context: ActionContext
    ): List<GameEvent> {
        val events = mutableListOf<GameEvent>()
        val outcomes = mutableListOf<SpellOutcome>()
        
        // Validate spell slot availability
        val caster = context.creatures[action.actorId]
            ?: throw IllegalArgumentException("Caster not found: ${action.actorId}")
        
        // TODO: Check spell slot availability from caster's spell slots
        
        // Check bonus action spell restriction (if applicable)
        if (action.isBonusAction) {
            // TODO: Enforce restriction that only cantrips can be cast as actions on the same turn
            // This requires tracking whether an action spell was already cast this turn
        }
        
        // Determine spell effect type and process accordingly
        when (val effect = action.spellEffect) {
            is SpellEffect.Attack -> {
                // Process spell attacks for each target
                for (targetId in effect.targets) {
                    val target = context.creatures[targetId]
                        ?: continue
                    
                    // Use AttackResolver for spell attack
                    val attackOutcome = attackResolver.resolveAttack(
                        attackBonus = caster.spellAttackBonus,
                        targetAC = target.armorClass,
                        seed = context.sessionId + context.roundNumber + targetId
                    )
                    
                    // Calculate damage if hit
                    val damageResult = if (attackOutcome.hit) {
                        damageCalculator.calculateDamage(
                            damageDice = effect.damageDice,
                            modifier = effect.damageModifier,
                            isCritical = attackOutcome.critical,
                            seed = context.sessionId + context.roundNumber + targetId + 1
                        )
                    } else {
                        null
                    }
                    
                    outcomes.add(
                        SpellOutcome(
                            targetId = targetId,
                            attackRoll = attackOutcome.roll,
                            saveRoll = null,
                            success = attackOutcome.hit,
                            damage = damageResult?.totalDamage,
                            damageType = effect.damageType?.name
                        )
                    )
                }
            }
            
            is SpellEffect.Save -> {
                // Process saving throws for each target
                for (targetId in effect.targets) {
                    val target = context.creatures[targetId]
                        ?: continue
                    
                    // Get target's saving throw modifier
                    val saveModifier = target.getSavingThrowModifier(effect.abilityType)
                    
                    // Use SavingThrowResolver for save
                    val saveOutcome = savingThrowResolver.resolveSave(
                        dc = effect.dc,
                        abilityType = effect.abilityType,
                        creatureModifier = saveModifier,
                        seed = context.sessionId + context.roundNumber + targetId
                    )
                    
                    // Calculate damage based on save result
                    val damageResult = if (effect.damageDice != null) {
                        val damage = damageCalculator.calculateDamage(
                            damageDice = effect.damageDice,
                            modifier = effect.damageModifier ?: 0,
                            isCritical = false,
                            seed = context.sessionId + context.roundNumber + targetId + 1
                        )
                        
                        // Half damage on successful save if applicable
                        if (saveOutcome.success && effect.halfDamageOnSave) {
                            DamageResult(damage.roll, damage.totalDamage / 2)
                        } else if (!saveOutcome.success) {
                            damage
                        } else {
                            null
                        }
                    } else {
                        null
                    }
                    
                    outcomes.add(
                        SpellOutcome(
                            targetId = targetId,
                            attackRoll = null,
                            saveRoll = DiceRoll(
                                diceType = 20,
                                count = 1,
                                modifier = saveModifier,
                                result = saveOutcome.roll
                            ),
                            success = saveOutcome.success,
                            damage = damageResult?.totalDamage,
                            damageType = effect.damageType?.name
                        )
                    )
                }
            }
            
            is SpellEffect.Utility -> {
                // Utility spells don't have attack or save outcomes
                // Just record that the spell was cast
            }
        }
        
        // Consume spell slot
        // TODO: Track spell slot consumption in caster's resources
        
        // Generate SpellCast event with outcomes
        events.add(
            SpellCast(
                sessionId = context.sessionId,
                timestamp = System.currentTimeMillis(),
                casterId = action.actorId,
                spellId = action.spellId,
                spellLevel = action.spellLevel,
                slotConsumed = action.spellLevel,
                targets = action.targets,
                outcomes = outcomes
            )
        )
        
        return events
    }
}
