package dev.questweaver.core.rules.actions

import dev.questweaver.core.rules.actions.models.ActionContext
import dev.questweaver.core.rules.actions.models.CastSpell
import dev.questweaver.core.rules.actions.models.SpellEffect
import dev.questweaver.domain.entities.Creature
import dev.questweaver.domain.events.GameEvent
import dev.questweaver.domain.events.SpellCast
import dev.questweaver.domain.events.SpellOutcome
import dev.questweaver.domain.values.AbilityType
import dev.questweaver.domain.values.DiceRoll

/**
 * Placeholder interface for saving throw resolution.
 * TODO: Implement as part of 05-combat-rules spec.
 */
interface SavingThrowResolver {
    fun resolveSave(
        dc: Int,
        abilityType: AbilityType,
        creatureModifier: Int,
        seed: Long
    ): SaveOutcome
}

/**
 * Represents the outcome of a saving throw.
 */
data class SaveOutcome(
    val roll: Int,
    val success: Boolean
)

/**
 * Processes spell casting actions with spell slot consumption and effect resolution.
 */
class SpellActionHandler(
    private val attackResolver: AttackResolver,
    private val savingThrowResolver: SavingThrowResolver,
    private val damageCalculator: DamageCalculator
) {
    /**
     * Processes a spell casting action.
     *
     * @param action Spell action details
     * @param context Current action context
     * @return List of events generated by the spell
     */
    suspend fun handleSpellCast(
        action: CastSpell,
        context: ActionContext
    ): List<GameEvent> {
        val caster = validateCaster(action.actorId, context)
        validateBonusActionRestriction(action)
        
        val outcomes = processSpellEffect(action.spellEffect, caster, context)
        
        // Consume spell slot
        // TODO: Track spell slot consumption in caster's resources
        
        return listOf(createSpellCastEvent(action, context, outcomes))
    }
    
    private fun validateCaster(casterId: Long, context: ActionContext): Creature {
        return context.creatures[casterId]
            ?: throw IllegalArgumentException("Caster not found: $casterId")
    }
    
    private fun validateBonusActionRestriction(action: CastSpell) {
        if (action.isBonusAction) {
            // TODO: Enforce restriction that only cantrips can be cast as actions on the same turn
            // This requires tracking whether an action spell was already cast this turn
        }
    }
    
    private suspend fun processSpellEffect(
        effect: SpellEffect,
        caster: Creature,
        context: ActionContext
    ): List<SpellOutcome> {
        return when (effect) {
            is SpellEffect.Attack -> processAttackSpell(effect, caster, context)
            is SpellEffect.Save -> processSaveSpell(effect, context)
            is SpellEffect.Utility -> emptyList()
        }
    }
    
    private suspend fun processAttackSpell(
        effect: SpellEffect.Attack,
        caster: Creature,
        context: ActionContext
    ): List<SpellOutcome> {
        return effect.targets.mapNotNull { targetId ->
            val target = context.creatures[targetId] ?: return@mapNotNull null
            processAttackAgainstTarget(effect, caster, target, targetId, context)
        }
    }
    
    private suspend fun processAttackAgainstTarget(
        effect: SpellEffect.Attack,
        caster: Creature,
        target: Creature,
        targetId: Long,
        context: ActionContext
    ): SpellOutcome {
        val attackOutcome = attackResolver.resolveAttack(
            attackBonus = caster.spellAttackBonus,
            targetAC = target.armorClass,
            seed = context.sessionId + context.roundNumber + targetId
        )
        
        val damageResult = if (attackOutcome.hit) {
            damageCalculator.calculateDamage(
                damageDice = effect.damageDice,
                modifier = effect.damageModifier,
                isCritical = attackOutcome.critical,
                seed = context.sessionId + context.roundNumber + targetId + 1
            )
        } else {
            null
        }
        
        return SpellOutcome(
            targetId = targetId,
            attackRoll = attackOutcome.roll,
            saveRoll = null,
            success = attackOutcome.hit,
            damage = damageResult?.totalDamage,
            damageType = effect.damageType?.name
        )
    }
    
    private suspend fun processSaveSpell(
        effect: SpellEffect.Save,
        context: ActionContext
    ): List<SpellOutcome> {
        return effect.targets.mapNotNull { targetId ->
            val target = context.creatures[targetId] ?: return@mapNotNull null
            processSaveAgainstTarget(effect, target, targetId, context)
        }
    }
    
    private suspend fun processSaveAgainstTarget(
        effect: SpellEffect.Save,
        target: Creature,
        targetId: Long,
        context: ActionContext
    ): SpellOutcome {
        val saveModifier = target.getSavingThrowModifier(effect.abilityType)
        
        val saveOutcome = savingThrowResolver.resolveSave(
            dc = effect.dc,
            abilityType = effect.abilityType,
            creatureModifier = saveModifier,
            seed = context.sessionId + context.roundNumber + targetId
        )
        
        val damageResult = calculateSaveDamage(effect, saveOutcome, targetId, context)
        
        return SpellOutcome(
            targetId = targetId,
            attackRoll = null,
            saveRoll = DiceRoll(
                diceType = 20,
                count = 1,
                modifier = saveModifier,
                result = saveOutcome.roll
            ),
            success = saveOutcome.success,
            damage = damageResult?.totalDamage,
            damageType = effect.damageType?.name
        )
    }
    
    private suspend fun calculateSaveDamage(
        effect: SpellEffect.Save,
        saveOutcome: SaveOutcome,
        targetId: Long,
        context: ActionContext
    ): DamageResult? {
        val damageDice = effect.damageDice ?: return null
        
        val damage = damageCalculator.calculateDamage(
            damageDice = damageDice,
            modifier = effect.damageModifier ?: 0,
            isCritical = false,
            seed = context.sessionId + context.roundNumber + targetId + 1
        )
        
        return when {
            saveOutcome.success && effect.halfDamageOnSave -> 
                DamageResult(damage.roll, damage.totalDamage / 2)
            !saveOutcome.success -> damage
            else -> null
        }
    }
    
    private fun createSpellCastEvent(
        action: CastSpell,
        context: ActionContext,
        outcomes: List<SpellOutcome>
    ): SpellCast {
        return SpellCast(
            sessionId = context.sessionId,
            timestamp = System.currentTimeMillis(),
            casterId = action.actorId,
            spellId = action.spellId,
            spellLevel = action.spellLevel,
            slotConsumed = action.spellLevel,
            targets = action.targets,
            outcomes = outcomes
        )
    }
}
